import "FishNFT"

transaction {
    prepare(acct: &Account) {
        if acct.contracts.get(name: "FishNFT") == nil {
            acct.contracts.add(
                name: "FishNFT",
                code: "import \"NonFungibleToken\"\nimport \"ViewResolver\"\nimport \"MetadataViews\"\n\naccess(all) contract FishNFT: NonFungibleToken {\n\n    access(all) let CollectionStoragePath: StoragePath\n    access(all) let CollectionPublicPath: PublicPath\n    access(all) let MinterStoragePath: StoragePath\n\n    access(all) event FishMinted(\n        id: UInt64,\n        recipient: Address,\n        species: String,\n        scientific: String,\n        length: UFix64,\n        latitude: Fix64,\n        longitude: Fix64,\n        timestamp: UFix64\n    )\n\n    access(all) struct FishMetadata {\n        access(all) let bumpShotUrl: String\n        access(all) let heroShotUrl: String\n        access(all) let hasRelease: Bool\n        access(all) let releaseVideoUrl: String?\n        access(all) let bumpHash: String\n        access(all) let heroHash: String\n        access(all) let releaseHash: String?\n        access(all) let longitude: Fix64\n        access(all) let latitude: Fix64\n        access(all) let length: UFix64\n        access(all) let species: String\n        access(all) let scientific: String\n        access(all) let timestamp: UFix64\n        access(all) let gear: String?\n        access(all) let location: String?\n\n        init(\n            bumpShotUrl: String,\n            heroShotUrl: String,\n            hasRelease: Bool,\n            releaseVideoUrl: String?,\n            bumpHash: String,\n            heroHash: String,\n            releaseHash: String?,\n            longitude: Fix64,\n            latitude: Fix64,\n            length: UFix64,\n            species: String,\n            scientific: String,\n            timestamp: UFix64,\n            gear: String?,\n            location: String?\n        ) {\n            self.bumpShotUrl = bumpShotUrl\n            self.heroShotUrl = heroShotUrl\n            self.hasRelease = hasRelease\n            self.releaseVideoUrl = releaseVideoUrl\n            self.bumpHash = bumpHash\n            self.heroHash = heroHash\n            self.releaseHash = releaseHash\n            self.longitude = longitude\n            self.latitude = latitude\n            self.length = length\n            self.species = species\n            self.scientific = scientific\n            self.timestamp = timestamp\n            self.gear = gear\n            self.location = location\n        }\n    }\n\n    access(all) resource NFT: NonFungibleToken.NFT {\n        access(all) let id: UInt64\n        access(all) let metadata: FishMetadata\n        access(all) let mintedBy: Address\n        access(all) let mintedAt: UFix64\n\n        init(\n            id: UInt64,\n            metadata: FishMetadata,\n            mintedBy: Address\n        ) {\n            self.id = id\n            self.metadata = metadata\n            self.mintedBy = mintedBy\n            self.mintedAt = getCurrentBlock().timestamp\n        }\n\n        access(all) fun getViews(): [Type] {\n            return [\n                Type<MetadataViews.Display>(),\n                Type<MetadataViews.Serial>(),\n                Type<MetadataViews.ExternalURL>(),\n                Type<MetadataViews.Traits>()\n            ]\n        }\n\n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: \"DerbyFish Catch - \".concat(self.metadata.species),\n                        description: \"A verified catch of \".concat(self.metadata.species).concat(\" (\").concat(self.metadata.scientific).concat(\") measuring \").concat(self.metadata.length.toString()).concat(\" inches\"),\n                        thumbnail: MetadataViews.HTTPFile(\n                            url: self.metadata.heroShotUrl\n                        )\n                    )\n                case Type<MetadataViews.Serial>():\n                    return MetadataViews.Serial(self.id)\n                case Type<MetadataViews.ExternalURL>():\n                    return MetadataViews.ExternalURL(\"https://derbyfish.flow.org/fish/\".concat(self.id.toString()))\n                case Type<MetadataViews.Traits>():\n                    let traits: [MetadataViews.Trait] = [\n                        MetadataViews.Trait(\n                            name: \"Species\",\n                            value: self.metadata.species,\n                            displayType: \"String\",\n                            rarity: nil\n                        ),\n                        MetadataViews.Trait(\n                            name: \"Scientific Name\",\n                            value: self.metadata.scientific,\n                            displayType: \"String\",\n                            rarity: nil\n                        ),\n                        MetadataViews.Trait(\n                            name: \"Length\",\n                            value: self.metadata.length,\n                            displayType: \"Number\",\n                            rarity: nil\n                        ),\n                        MetadataViews.Trait(\n                            name: \"Latitude\",\n                            value: self.metadata.latitude,\n                            displayType: \"Number\",\n                            rarity: nil\n                        ),\n                        MetadataViews.Trait(\n                            name: \"Longitude\",\n                            value: self.metadata.longitude,\n                            displayType: \"Number\",\n                            rarity: nil\n                        ),\n                        MetadataViews.Trait(\n                            name: \"Has Release\",\n                            value: self.metadata.hasRelease,\n                            displayType: \"Boolean\",\n                            rarity: nil\n                        ),\n                        MetadataViews.Trait(\n                            name: \"Catch Date\",\n                            value: self.metadata.timestamp,\n                            displayType: \"Date\",\n                            rarity: nil\n                        )\n                    ]\n\n                    if let gear = self.metadata.gear {\n                        traits.append(\n                            MetadataViews.Trait(\n                                name: \"Gear\",\n                                value: gear,\n                                displayType: \"String\",\n                                rarity: nil\n                            )\n                        )\n                    }\n\n                    if let location = self.metadata.location {\n                        traits.append(\n                            MetadataViews.Trait(\n                                name: \"Location\",\n                                value: location,\n                                displayType: \"String\",\n                                rarity: nil\n                            )\n                        )\n                    }\n\n                    return MetadataViews.Traits(traits)\n            }\n            return nil\n        }\n    }\n\n    access(all) resource Collection: NonFungibleToken.Collection {\n        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        access(all) fun getSupportedNFTTypes(): {Type: Bool} {\n            let supportedTypes: {Type: Bool} = {}\n            supportedTypes[Type<@FishNFT.NFT>()] = true\n            return supportedTypes\n        }\n\n        access(all) fun isSupportedNFTType(type: Type): Bool {\n            return type == Type<@FishNFT.NFT>()\n        }\n\n        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {\n            let token <- self.ownedNFTs.remove(key: withdrawID)\n                ?? panic(\"Could not withdraw an NFT with the provided ID from the collection\")\n\n            return <-token\n        }\n\n        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {\n            let token <- token as! @FishNFT.NFT\n            let id = token.id\n\n            let oldToken <- self.ownedNFTs[token.id] <- token\n            destroy oldToken\n        }\n\n        access(all) fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        access(all) fun getLength(): Int {\n            return self.ownedNFTs.length\n        }\n\n        access(all) fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {\n            return (&self.ownedNFTs[id] as &{NonFungibleToken.NFT}?)\n        }\n\n        access(all) fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {\n            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {\n                return nft as &{ViewResolver.Resolver}\n            }\n            return nil\n        }\n\n        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {\n            return <-FishNFT.createEmptyCollection(nftType: Type<@FishNFT.NFT>())\n        }\n    }\n\n    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {\n        return <- create Collection()\n    }\n\n    access(all) resource NFTMinter {\n        access(all) var nextID: UInt64\n\n        init() {\n            self.nextID = 1\n        }\n\n        access(all) fun mintNFT(\n            recipient: Address,\n            metadata: FishMetadata\n        ): @FishNFT.NFT {\n            let newNFT <- create FishNFT.NFT(\n                id: self.nextID,\n                metadata: metadata,\n                mintedBy: self.account.address\n            )\n\n            emit FishMinted(\n                id: self.nextID,\n                recipient: recipient,\n                species: metadata.species,\n                scientific: metadata.scientific,\n                length: metadata.length,\n                latitude: metadata.latitude,\n                longitude: metadata.longitude,\n                timestamp: metadata.timestamp\n            )\n\n            self.nextID = self.nextID + 1\n\n            return <-newNFT\n        }\n\n        access(all) fun mintNFTToCollection(\n            recipient: &{NonFungibleToken.Collection},\n            metadata: FishMetadata\n        ) {\n            let nft <- self.mintNFT(\n                recipient: recipient.owner?.address ?? self.account.address,\n                metadata: metadata\n            )\n            recipient.deposit(token: <-nft)\n        }\n    }\n\n    init() {\n        self.CollectionStoragePath = /storage/FishNFTCollection\n        self.CollectionPublicPath = /public/FishNFTCollection\n        self.MinterStoragePath = /storage/FishNFTMinter\n\n        let collection <- create Collection()\n        self.account.storage.save(<-collection, to: self.CollectionStoragePath)\n\n        let collectionCap = self.account.capabilities.storage.issue<&FishNFT.Collection>(self.CollectionStoragePath)\n        self.account.capabilities.publish(collectionCap, at: self.CollectionPublicPath)\n\n        let minter <- create NFTMinter()\n        self.account.storage.save(<-minter, to: self.MinterStoragePath)\n    }\n}"
            )
        }
    }
} 